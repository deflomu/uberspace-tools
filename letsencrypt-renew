#!/bin/sh
PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin
valid_days=21
letsencrypt_dir="$HOME/.config/letsencrypt"
cert_dir=${letsencrypt_dir}/live
cert_file='cert.pem'
domain=$(grep -e "[ \t]*domains.*" ${letsencrypt_dir}/cli.ini| sed "s/ //g" |cut -d "=" -f2 | cut -d "," -f1)
force=0

usage() {
  cat >&2 <<__EOF__

Usage:
$0  [-s wait-time] [-f]

Options:
  -h               show this message
  -s wait-time     time in seconds to wait before checking for
                   certificate renewal
  -c               cleanup bogus certificates like domain.tld-0001, created due to a
                   bug in letsencrypt when a domain was removed from cli.ini
  -f               force renewal, even if certificate is still valid

__EOF__

}

cleanup_certificates() {
  echo "WARNING: Going to remove ALL -0001, -0002 etc. files and directories"
  echo "in ~/.config/letsencrypt - make sure there are no needed certificates there."
  cd ${letsencrypt_dir}
  
  # this is a buggy workaround. Does not cover -0010 and greater numbers
  # deletes all these files and directories without asking further.
  # beware. May eat your dog.
  for f in live/${domain}-000[1-9]; do
    echo "  deleting $f..."
    rm -rf $f;
  done
  for f in archive/${domain}-000[1-9]; do
    echo "  deleting $f..."
    rm -rf $f;
  done
  for f in renewal/${domain}-000[1-9].conf; do
    echo "  deleting $f..."
    rm -rf $f;
  done
  echo "Cleanup done."
}


if [ "$domain" == "" ]; then
  echo "the 'domains' variable in ${letsencrypt_dir} seems to be malformed or missing."
  echo "Please check this file. (Hint: have you run uberspace-letsencrypt already?)"
  exit 1
fi


# process arguments
while getopts ":cfhs:" opt; do
  case "$opt" in
    s)
      # sleep x seconds - if x is an integer, else do nothing
      re='^[0-9]+$'
      if [[ "$OPTARG" =~ $re ]] ; then
        echo "Sleeping $OPTARG seconds..."
        sleep $OPTARG
      else
        echo "Invalid option: -$OPTARG is no Integer" >&2
        usage
      fi
      ;;
    h)
      usage
      exit 0
      ;;
    f)
      force=1
      ;;
    c)
      cleanup_certificates
      exit 0
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      usage
      exit 1
      ;;
  esac
done
#shift $((OPTIND-1))

# find all certificates, put in a list
export certs="$(find $cert_dir/$domain*/ -iname $cert_file | sort -k1)"

for cert in $certs; do

# check certificate validation date
openssl x509 -checkend $(( $valid_days * 86400 )) -in "$cert" > /dev/null

# renew certificates if they are less than only 10 more days valid
if [ $? != 0 -o "$force" == 1 ]; then
  echo -e "\nProcessing certificate file $cert..."
  
  # Try to get path of new certificate from letsencrypt script.
  # This is an *ugly* hack - but I don't know another workaround for a bug
  # (or missing feature) in LetsEncrypt, see
  # https://github.com/letsencrypt/letsencrypt/issues/2071
  # Especially, if a domain.tld was removed from cli.ini, LetsEncrypt does not
  # use the old directory/certificate, but creates a new one with the ugly name
  # domain.tld-0001 - and leaves the old cert untouched.
    # If we would just "renew" it with the old path, the new cert would be created,
    # but not used, and the old one would expire!
    #
    # Here we search for fullchain.pem and suck out the paths string using sed:
    # First we get the output of letsencrypt, and re-concat maybe-wrapped lines
    # into one again, removing spaces at the beginning, and then removing all "\n"
    output=`letsencrypt certonly -d $domain | sed "s/^ *//" |tr -d "\n"`

    if ! echo $output | grep "/fullchain.pem"; then
      echo -e "Let's Encrypt apparently could not renew the certificate. Error output:\n"
      echo $output
      exit 1
    fi

    # now we can parse it correctly and get the path of the new certificate.
    # first make sure that "fullchain.pem" is a part of the output. This is necessary
    # as sed regex grouping does return the whole string if the group is not found.
    # Then cut the path out of the letsencrypt command's output
    new_cert_dir=`echo $output | grep "fullchain.pem" | sed -r "s/(^.+)(\/home\/.+)(\/fullchain.pem.*$)/\2/"`

    if [ "$new_cert_dir" == "" ]; then
      echo "Error parsing the file path of the new certificate."
      echo "Please check manually wether the certificate was created"
      echo -e "and add it to the webserver using uberspace-add-certificate.\n"
      echo -e "letsencrypt output:\n$output"
      exit 1
    elif [ "$new_cert_dir" == "$cert_dir/$domain" ]; then
      # cert path has not changed
      echo "Adding renewed certificate from $cert_dir/$domain."
      uberspace-add-certificate -k $cert_dir/$domain/privkey.pem -c $cert_dir/$domain/$cert_file
    else
      # cert path has changed, probably to domain.tld-0001 etc.
      echo "   WARNING: The path to the certificate has changed - maybe Let's Encrypt"
      echo "            has generated a new one with a new path:"
      echo "            $new_cert_dir"
      echo "            This is a known problem of Let's Encrypt"
      echo "            Trying to workaround the problem and add the new certificate with the new path."
      uberspace-add-certificate -k $new_cert_dir/privkey.pem -c $new_cert_dir/$cert_file
    fi
  fi
done
